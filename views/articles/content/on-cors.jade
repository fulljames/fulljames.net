:markdown
    A lot of what I'll post here is likely to be documentation of problems solved in my day job - or to put it another way the thornier issues that crop up in projects and deserve to be written down. As much as an aide-memoire for me as anything, but hopefully others will find them interesting too. The first such to be tackled is Cross Origin Resource Sharing (CORS), or the black art of AJAX calls to remote domains.

    ### The what?

    It used to be simple. The law of the [Same Origin Policy](http://en.wikipedia.org/wiki/Same_origin_policy) was Thou Shalt Not Make AJAX Requests to Other Domains. And by domains we mean subdomains and alternate ports as well. Just to be clear. Your browser won't allow it.

    There is of course a perfectly logical reason for this. You hit some remote endpoint for Javascript, you have absolutely no idea what you're going to get back. It could be perfectly innocent JSON data. Or it could be some hideous eval() script that compromises your user's browser, device, brain, whatever. So it wasn't allowed.

    Instead you would proxy the request. That is, you would make an AJAX call to an endpoint on your own domain, where behind the scenes on the server-side a request would send off for the data, make sure it wasn't going to kill anyone, and send a clean result back to the client.

    All fine, but with a proxy you do have an extra hop in the journey of the data. Not usually a big deal but not as efficient as going direct to the data source from the client.

    So that's the way things used to be. But now, if you're careful, you can break the old law of the Same Origin Policy and request data from remote domains using Javascript. You can even do it securely. Here's how.

    ### XmlHttpRequest 2.0

    Whenever you make an AJAX request, whether it's in raw Javascript or abstracted by the likes of jQuery, you're ultimately using your browser's implementation of the [XmlHttpRequest](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest) protocol. This is the bit that checks domains, manages the lifecycle of the connection, stops you from doing anything stupid, etc etc. XHR 1 didn't like going cross-origin. XHR 2 doesn't care.

    Well, it does care. It's less fussy but it will still baulk at things it considers stupid. What it does allow is cross-origin connections where there is a trusted relationship, and this is established by the headers that the request sends and the headers that the response returns. Together this is known as HTTP Access Control, and there's an excellent [overview of the subject](https://developer.mozilla.org/en-US/docs/HTTP_access_control) on the Mozilla Developer Network. However here I'm just going to step through an example I've used recently.

    Let's consider a typical AJAX request using jQuery (other frameworks are available):

        $.ajax {
            url: '/my/endpoint',
            type: 'GET'
            success: function(response) {
                console.log(response);
            },
            error: function(jqXhr,status,message) {
                console.log(message);
            }
        }

    At this point we're hitting an endpoint relative to the current domain, so everything will be fine. But as soon as we change the URL parameter to an remote one, you'll get an error something like this:

        XMLHttpRequest cannot load http://cors.12412.org/. Origin http://fulljames.net is not allowed by Access-Control-Allow-Origin.

    This is Chrome's interpretation of it but you'll see something similar in most other browsers. What it means is that the remote server has rejected the request because, for CORS to work, either the "origin" domain must whitelisted or the server configured to allow access from any domain. To create this whitelisting, we need to set a header on the server's response to the AJAX request:

        res.header("Access-Control-Allow-Origin", "http://fulljames.net");

    In this case it's a simple Node server (full details on the demo later) but there are ways and means for most technologies, a good number are listed at the very useful http://enable-cors.org/. We're setting the allowed domain to be specific here, so only requests from http://fulljames.net will be let through, but you can also list multiple domains or use the * wildcard to permit anyone to call it.

    This is fine, and will work for simple GET and POST requests, but consider some other things we might want to do:

    * Send a PUT or DELETE to an API.
    * Secure our request using an Authorization header

    We'll need some additional header science for this to work.

    ### Getting secure

    As part of its quite sensible security checks, XHR 2 only allows GET or POST requests by default. Try otherwise and you'll get an error something like:

        XMLHttpRequest cannot load http://cors.12412.org/. Method PUT is not allowed by Access-Control-Allow-Methods.

    But we can easily set this header in the response to let the other methods through.

        res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE");

    Now we can happily hit our remote endpoint with any of those four HTTP methods and all will be good. But if you have the network panel in your browser's console open, or use a web debugger such as [Fiddler2](http://www.fiddler2.com/fiddler2/) or [Charles](http://www.charlesproxy.com/), you'll notice something else start to happen.

        Request URL:http://cors.12412.org/
        Request Method:OPTIONS
        Status Code:200 OK

    Request Method OPTIONS? What the hell is that? As the MDN article explains, under certain conditions the browser will "preflight" the request and check that the method it's being asked to use is allowed. This is where the OPTIONS request comes in, its effectively a conversation with the server that goes something like:

        BROWSER: "Hey server, is it cool if I send you this PUT request?"
        SERVER: "Hey browser, why not, send it over!" OR "Are you kidding? Don't even try that."

    The 'send it over' response comes if the method being asked for matches the settings in the Access-Control-Allow-Methods header. In that case the browser will then automatically fire the original request and your Javascript will continue as expected. If not, the OPTIONS request will fail and nothing else will happen. Typically you would code for this case in your Javascript so you can let the user know something went wrong.

    As well protecting the server from undesirable incoming requests, this method of access control also helps to protect the browser and the user. After all, an AJAX request can potentially contain sensitive data, so a way of checking if the server is going to do something sensible with it before sending it has to be a good idea.

    So what if we also want to identify the user as we pass our request to the server? Let's say in some other part of our application we've authenticated the user and have received a bearer token that we can insert into an Authorization header on our request. That will mean changing the AJAX code to look more like this:

        $.ajax {
            url: '//path/to/remote/endpoint',
            type: 'GET'
            beforeSend: function(xhr) {
                xhr.setRequestHeader('Authorization', 'Bearer myawesometoken');
            },
            success: function(response) {
                console.log(response);
            },
            error: function(jqXhr,status,message) {
                console.log(message);
            }
        }

    We can fire this request off as is, but if you've spotted a pattern developing here you may have anticipated that the response is going to be an error:

        XMLHttpRequest cannot load http://cors.12412.org/. Request header field Authorization is not allowed by Access-Control-Allow-Headers.

    Yes, another aspect of the security in Access Control is that we have to grant access in the response headers for either named request headers, or the wildcard * for anything.

        res.header("Access-Control-Allow-Headers", "Authorization");

    Once this is present in the response, our request-with-auth-header can now get through. Of course its still up to the server to verify that the token is good and the request should be dignified with a response, but at least its going to get there. Note also that as soon as you start applying an Authorization header in your requests, they will be automatically pre-flighted regardless of the HTTP method used.

    ### There's always a catch

    Of course, as there always is with new, fun internet techniques, there is a browser support caveat. IE8 and IE9 don't implement XHR 2.0. Oh.

    They do, in Microsoft-of-yore's special way, implement their own protocol, [XDomainRequest](http://). But this is pretty useless for our more advanced cases as you can only send GET or POST requests and you can't set custom headers of any kind which means our authentication scenario is out of the window.

    IE10, fortunately, is a product of modern Microsoft and implements XHR 2 and all the above examples will work perfectly.

    At the time of writing IE8 and IE9 still represent a pretty hefty chunk of users and so supporting these browsers is a must. So once the warm glow of making something new and cool work has worn off, we need to find a way around it.

    And in another stroke of good fortune for this narrative, someone has already solved the problem. Well, ish. You may be aware that Adobe added a cross-domain request protocol to Flash some time ago, where instead of setting response headers you instead use a XML policy file on the remote server to control access. It's not perfect, but it will do most of what we want. So yep, we're going to shim one cack-handed proprietary implementation with a different cack-handed proprietary implementation. Yay!

    To do this we're going to use the [flXHR jQuery plugin](http://github.com), which is an optimised version of a shim originally created by Kyle Simpson and no-longer (understandably) maintained. Before I go into detail, here are the rules:

    * No PUT or DELETE support in the Flash protocol
    * No custom headers on GET requests ([long-standing Flash bug](http://#))

    So essentially we have to channel anything that needs authentication via a POST request and let the server sort it out. You could either set up IE<10-specific endpoints to handle this, or in the regular endpoint look for the referer which will be a known .swf file. The AJAX code is going to end up looking like this:

        var remoteProtocol = 'http';
        var remoteUrl = '//remote.com';

        var verb = 'GET'; // or 'POST', 'PUT', 'DELETE'
        var data = null;

        if (!$.support.cors) {
            $.flxhrProxy.registerOptions(remoteProtocol+':'+remoteUrl,{});
            verb = 'POST';
            data = { message: 'Test message' };
        }

        $.ajax({
            url: remoteUrl + '/path/to/endpoint',
            type: verb,
            data: data,
            beforeSend: function(xhr) {
                xhr.setRequestHeader('Authorization', 'Bearer myawesometoken');
            },
            flXHR: !$.support.cors,
            success: function(response) {
                $('#debug').text(response);
            },
            error: function(jqXhr,status,message) {
                $('#debug').text(message.toString());
            }
        });

    We're setting the HTTP verb as a variable directly but most likely this would come from some other part of the application. We're also setting a placeholder, 'data', for a message body because the POST-via-Flash will be converted to a GET without one.

    Inside the if statement, $.support.cors is a jQuery feature-detection helper which tells us whether or not we're in a CORS-compatible browser. If not, we need to register the remote domain as one that the shim is going to use (hence why we parameterised it), force the verb to a POST and set a message body.

    The AJAX request itself is pretty standard, the only addition being the 'flXHR' option which we set to the opposite of $.support.cors. So only our non-compatible browsers will attempt to use this transport.

    Now if you hit the endpoint in IE8 or IE9, with an appropriate crossdomain.xml policy file in place on the server, you should get an authenticable CORS response to any POST request. Without forcing the verb to POST you would end up with a 401 Not Authorized error from a GET (no headers sent) or a No Transport error from PUT or DELETE (Flash didn't even try).

    Like I said, not perfect, but usable.

    <div class="table">
        <table>
        <caption>Browser support for authenticated CORS requests</caption>
        <thead>
        <tr>
            <th></th>
            <th>Chrome</th>
            <th>Firefox (3.5+)</th>
            <th>Safari (4+)</th>
            <th>IE 8/9</th>
            <th>IE 10</th>
            <th>Safari iOS</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>GET</th>
            <td>OK</td>
            <td>OK</td>
            <td>OK</td>
            <td>NO <span class="note">1</span></td>
            <td>OK</td>
            <td>OK</td>
        </tr>
        <tr>
            <th>POST</th>
            <td>OK</td>
            <td>OK</td>
            <td>OK</td>
            <td>OK <span class="note">2</span></td>
            <td>OK</td>
            <td>OK</td>
        </tr>
        <tr>
            <th>PUT</th>
            <td>OK</td>
            <td>OK</td>
            <td>OK</td>
            <td>NO <span class="note">3</span></td>
            <td>OK</td>
            <td>OK</td>
        </tr>
        <tr>
            <th>DELETE</th>
            <td>OK</td>
            <td>OK</td>
            <td>OK</td>
            <td>NO <span class="note">3</span></td>
            <td>OK</td>
            <td>OK</td>
        </tr>
        </tbody>
        </table>

        <ol>
            <li>Cannot send custom header with flXHR shim. Non-authenticated GET requests are possible.</li>
            <li>Using flXHR shim.</li>
            <li>No transport available in XDomainRequest or Flash cross-domain protocols.</li>
        </ol>
    </div>

    ### Making use of it

    What you've ended up with is a (fairly) universal method to make authenticated AJAX calls between domains. The actual use-case for this might not be very common at the moment, as most API traffic is probably either non-authenticated or passed through a proxy, but now that CORS support is more widely implemented it should become more widespread.

    For a web application's internal API you're likely to be hitting the same domain the site is running on, so all this is fairly irrelevant. However if you're opening up a service for third parties to consume and you want to authenticate their requests (Hello, Twitter!) this is the kind of thing you're going to need to be specifying unless you require use of a proxy. And in this age of cloud services and cost-per-compute-time, reducing load on your own application now that you can directly hit remote endpoints from a browser has to be good, right?

    There are some drawbacks, of course. The lack of solid IE support being one, and the notion of passing a bearer token as identification like this may also meet some resistance (try to avoid doing it unless using HTTPS), but as a reference for what can be done at least hopefully it's useful to see it in action.

    Hit the buttons below in various browsers to see what happens!

    ### The demo

    Integration TBC

    For now, see http://cors.fulljames.net
