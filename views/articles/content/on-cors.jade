:markdown
    A lot of what I'll post here is likely to be documentation of problems solved in my day job - or to put it another way the thornier issues that crop up in projects and deserve to be written down. As much as an aide-memoire for me as anything, but hopefully others will find them interesting too. The first such to be tackled is Cross Origin Resource Sharing (CORS), or the black art of AJAX calls to remote domains.

    ### The what?

    It used to be simple. The law of the [Same Origin Policy](http://en.wikipedia.org/wiki/Same_origin_policy) was Thou Shalt Not Make AJAX Requests to Other Domains. And by domains we mean subdomains and alternate ports as well. Just to be clear. Your browser won't allow it.

    There is of course a perfectly logical reason for this. You hit some remote endpoint for Javascript, you have absolutely no idea what you're going to get back. It could be perfectly innocent JSON data. Or it could be some hideous eval() script that compromises your user's browser, device, brain, whatever. So it wasn't allowed.

    Instead you would proxy the request. That is, you would make an AJAX call to an endpoint on your own domain, where behind the scenes on the server-side a request would send off for the data, make sure it wasn't going to kill anyone, and send a clean result back to the client.

    All fine, but with a proxy you do have an extra hop in the journey of the data. Not usually a big deal but not as efficient as going direct to the data source from the client.

    So that's the way things used to be. But now, if you're careful, you can break the law of the Same Origin Policy and request data from remote domains using Javascript. You can even do it securely. Here's how.

    ### XmlHttpRequest 2.0

    Whenever you make an AJAX request, whether it's in raw Javascript or abstracted by the likes of jQuery, you're ultimately using your browser's implementation of the [XmlHttpRequest](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest) protocol. This is the bit that checks domains, manages the lifecycle of the connection, stops you from doing anything stupid, etc etc. XHR 1 didn't like going cross-origin. XHR 2 doesn't care.

    Well, it does care. It's less fussy but it will still baulk at things it considers stupid. What it does allow is cross-origin connections where there is a trusted relationship, and this is established by the headers that the request sends and the headers that the response returns.

    Let's consider a typical AJAX request using jQuery (other frameworks are available):

        $.ajax {
            url: '/my/endpoint',
            type: 'GET'
            success: function(response) {
                console.log(response);
            },
            error: function(jqXhr,status,message) {
                console.log(message);
            }
        }

    At this point we're hitting an endpoint relative to the current domain, so everything will be fine. But as soon as we change the URL parameter to an remote one, you'll get an error something like this:

        XMLHttpRequest cannot load http://cors.12412.org/. Origin http://fulljames.net is not allowed by Access-Control-Allow-Origin.

    This is Chrome's interpretation of it but you'll see something similar in most other browsers. What it means is that the remote server has rejected the request because, for CORS to work, either the "origin" domain must whitelisted or the server configured to allow access from any domain. To create this whitelisting, we need to set a header on the server's response to the AJAX request:

        res.header("Access-Control-Allow-Origin", "http://fulljames.net");

    In this case it's a simple Node server (full details on the demo later) but there are ways and means for most technologies, a good number are listed at the very useful http://enable-cors.org/. We're setting the allowed domain to be specific here, so only requests from http://fulljames.net will be let through, but you can also list multiple domains or use the * wildcard to permit anyone to call it.

    ### The browsers

    Of course, as there always is with new, fun internet techniques, there is a browser support caveat. IE8 and IE9 don't implement XHR 2.0. Oh.

    They do, in Microsoft-of-yore's special way, implement their own protocol, XDomainRequest. But this is pretty useless as you can only send GET or POST requests and you can't set custom headers which means any kind of authentication is out of the window.